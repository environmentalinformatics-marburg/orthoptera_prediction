
R version 3.3.0 (2016-05-03) -- "Supposedly Educational"
Copyright (C) 2016 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R ist freie Software und kommt OHNE JEGLICHE GARANTIE.
Sie sind eingeladen, es unter bestimmten Bedingungen weiter zu verbreiten.
Tippen Sie 'license()' or 'licence()' für Details dazu.

R ist ein Gemeinschaftsprojekt mit vielen Beitragenden.
Tippen Sie 'contributors()' für mehr Information und 'citation()',
um zu erfahren, wie R oder R packages in Publikationen zitiert werden können.

Tippen Sie 'demo()' für einige Demos, 'help()' für on-line Hilfe, oder
'help.start()' für eine HTML Browserschnittstelle zur Hilfe.
Tippen Sie 'q()', um R zu verlassen.

> # Preprocess MODIS dataset
> # Thomas Nauss
> 
> if(Sys.info()["sysname"] == "Windows"){
+   source("F:/analysis/orthoptera/orthoptera_prediction/src/00_set_environment.R")
+ } else {
+   source("/media/tnauss/myWork/analysis/orthoptera/orthoptera_prediction/src/00_set_environment.R")
+ }
Lade nötiges Paket: caret
Lade nötiges Paket: lattice
Lade nötiges Paket: ggplot2
Lade nötiges Paket: gridExtra
Lade nötiges Paket: latticeExtra
Lade nötiges Paket: RColorBrewer

Attache Paket: 'latticeExtra'

The following object is masked from 'package:ggplot2':

    layer

Lade nötiges Paket: raster
Lade nötiges Paket: sp
Lade nötiges Paket: satellite
Lade nötiges Paket: Rcpp
Lade nötiges Paket: plyr
Lade nötiges Paket: dplyr

Attache Paket: 'dplyr'

The following objects are masked from 'package:plyr':

    arrange, count, desc, failwith, id, mutate, rename, summarise,
    summarize

The following objects are masked from 'package:raster':

    intersect, select, union

The following object is masked from 'package:gridExtra':

    combine

The following objects are masked from 'package:stats':

    filter, lag

The following objects are masked from 'package:base':

    intersect, setdiff, setequal, union


Attache Paket: 'gpm'

The following object is masked from 'package:satellite':

    lutInfo

Lade nötiges Paket: leaflet
'localArcPath' does not exist, and will be created in 'D:/active/idessa/sa_rainfall/data/modis/modis_arc/'. Consult '?MODISoptions' if you want to change it!
'outDirPath' does not exist, it will be created in 'D:/active/idessa/sa_rainfall/data/modis/processed/'. Consult '?MODISoptions' if you want to change it!
MODIS_manual: https://ivfl-rio.boku.ac.at/owncloud/public.php?service=files&t=660dc830afb091237cc40b3dea2fdf6b


Attache Paket: 'MODIS'

The following object is masked from 'package:base':

    file.size

rgdal: version: 1.1-10, (SVN revision 622)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 2.0.1, released 2015/09/15
 Path to GDAL shared files: C:/Users/tnauss/Documents/R/win-library/3.3/rgdal/gdal
 Loaded PROJ.4 runtime: Rel. 4.9.2, 08 September 2015, [PJ_VERSION: 492]
 Path to PROJ.4 shared files: C:/Users/tnauss/Documents/R/win-library/3.3/rgdal/proj
 Linking to sp version: 1.2-3 
rgeos version: 0.3-21, (SVN revision 540)
 GEOS runtime version: 3.5.0-CAPI-1.9.0 r4084 
 Linking to sp version: 1.2-3 
 Polygon checking: TRUE 

Warnmeldungen:
1: Paket 'glcm' wurde unter R Version 3.3.1 erstellt 
2: Paket 'caret' wurde unter R Version 3.3.1 erstellt 
3: Paket 'lattice' wurde unter R Version 3.3.1 erstellt 
4: Paket 'Rcpp' wurde unter R Version 3.3.1 erstellt 
5: Paket 'dplyr' wurde unter R Version 3.3.1 erstellt 
6: Paket 'mapview' wurde unter R Version 3.3.1 erstellt 
7: Paket 'readxl' wurde unter R Version 3.3.2 erstellt 
8: Paket 'rgeos' wurde unter R Version 3.3.1 erstellt 
> 
> initOTB("C:/OSGeo4W64/bin/")
[1] "C:/OSGeo4W64/bin/"
> download <- FALSE
> compute <- TRUE
> 
> 
> # Download MODIS tiles ---------------------------------------------------------
> if(download){
+   # Read observation data for dates
+   obsv <- read.table(paste0(path_obsv, "lvl0300_biodiversity_data.csv"), 
+                      header = TRUE, sep = ";", dec = ",")
+   dates <- gsub("-", "", substring(unique(obsv$date_nocloud), 1, 8), "-")
+   
+   # Set processing options
+   MODISoptions(localArcPath = path_modis_local_arc, outProj = "+init=epsg:32737",
+                outDirPath = path_modis_out_dir, MODISserverOrder = c("LAADS", "LPDAAC"),
+                gdalPath = "C:/OSGeo4W64/bin")
+   
+   # Download MODIS tiles
+   modis_product <- c("MOD09GA", "MOD09A1", "MOD09Q1", "MOD11A1",
+                      "MYD09GA", "MYD09A1", "MYD09Q1", "MYD11A1")
+   
+   for(pdct in modis_product){
+     for(dts in dates){
+       job_name <- paste0(pdct, "_TZS")
+       collection <- getCollection(pdct, forceCheck = TRUE)
+       runGdal(pdct, collection = collection, job = job_name, 
+               tileH = 21, tileV = 9,
+               begin = dts, end = dts)
+     }
+   }
+ }
> 
> # Prepare MODIS dataset --------------------------------------------------------
> # modis_product <- c("MOD09GA", "MOD09A1", "MOD09Q1",
> #                    "MYD09GA", "MYD09A1", "MYD09Q1")
> if(compute){
+   modis_sensors <- c("mod", "myd")
+   
+   tmin <- as.POSIXct(strptime("2002-01-01", "%Y-%m-%d"), tz = "UTC")
+   tmax <- as.POSIXct(strptime("2013-01-01", "%Y-%m-%d"), tz = "UTC")
+   
+   # Create one raster tile for each observation plot
+   obsv_shp_wgs <- readRDS(file = paste0(path_results, "obsv_shp_wgs.rds"))
+   obsv_shp_arc <- readRDS(file = paste0(path_results, "obsv_shp_arc.rds"))
+   
+   obsv_shp_wgs_modis <- obsv_shp_wgs[obsv_shp_wgs@data$date >= tmin & 
+                                        obsv_shp_wgs@data$date <= tmax,]
+   obsv_shp_arc_modis <- obsv_shp_wgs[obsv_shp_arc@data$date >= tmin & 
+                                        obsv_shp_arc@data$date <= tmax,]
+   
+   saveRDS(obsv_shp_wgs_modis, file = paste0(path_results, "obsv_shp_wgs_modis.rds"))
+   saveRDS(obsv_shp_arc_modis, file = paste0(path_results, "obsv_shp_arc_modis.rds"))
+   
+   for(sensor in modis_sensors){
+     
+     if(sensor == "mod"){
+       pdct <- "MOD09A1"
+     } else {
+       pdct <- "MYD09A1"
+     }
+     
+     job_name <- paste0(pdct, "_TZS")
+     modis_files <- list.files(paste0(path_modis_out_dir, job_name),
+                               pattern = glob2rx("*sur_refl_b0*tif"), 
+                               full.names = TRUE)
+     
+     for(prj in c("wgs", "arc")){
+       if(prj == "wgs"){
+         obsv_shp <- obsv_shp_wgs_modis
+       } else {
+         obsv_shp <- obsv_shp_arc_modis
+       }
+       obsv_shp <- spTransform(obsv_shp, crs(stack(modis_files[1])))
+       
+       # Create one raster tile for each observation plot
+       time_match <- timeMatch(a = obsv_shp@data$date, 
+                               b = unique(as.POSIXct(
+                                 strptime(substr(basename(modis_files), 10, 16),
+                                          "%Y%j"), tz = "UTC")))
+       
+       modis_snip <- lapply(seq(nrow(time_match)), function(i){
+         if(i %% 10 == 0) print(paste0("Processing ", i, " of ", nrow(time_match)))
+         snipRaster(raster=stack(modis_files[grep(strftime(time_match$b[i], "%Y%j"), 
+                                                  modis_files)]), 
+                    spatial=obsv_shp[i,], selector = NULL,
+                    buffer=4500, byid = TRUE)
+       })
+       modis_snip <- unlist(modis_snip)
+       names(modis_snip) <- time_match$a
+       saveRDS(modis_snip, file = paste0(path_results, "modis_", sensor, "_snip_", prj, ".rds"))
+       
+       # Compute pca for all plots
+       modis_pca <- pca(modis_snip, ignore_names = TRUE, 
+                        center = TRUE, scale = TRUE)
+       saveRDS(modis_pca, file = paste0(path_results, "modis_pca_", prj, ".rds"))
+       
+       # Compute spectral indices for all plots
+       modis_mspec_indices <- lapply(seq(length(modis_snip)), function(i){
+         if(i %% 10 == 0) print(paste0(i))
+         mSpecIndices(blue = modis_snip[[i]][[3]], green = modis_snip[[i]][[4]], 
+                      red = modis_snip[[i]][[1]], nir = modis_snip[[i]][[2]])
+       })  
+       names(modis_mspec_indices) <- names(modis_snip)
+       saveRDS(modis_mspec_indices, file = paste0(path_results, "modis_mspec_indices_", prj, ".rds"))
+       
+       # Compute Haralick textures for all plots based on PCA
+       minv <- min(unlist(lapply(modis_pca, function(s){minValue(s$PC1)})))
+       maxv <- max(unlist(lapply(modis_pca, function(s){maxValue(s$PC1)})))
+       modis_pca_otb_txt <- lapply(seq(length(modis_pca)), function(i){
+         if(i %% 10 == 0) print(paste0(i))
+         oth <- otbTexturesHaralick(x=modis_pca[[i]]$PC1, path_output = path_temp, 
+                                    return_raster = TRUE, 
+                                    parameters.xyrad=list(c(1,1)),
+                                    parameters.xyoff=list(c(1,1)),
+                                    parameters.minmax=c(minv, maxv),
+                                    parameters.nbbin = 16,
+                                    texture="all",
+                                    channel = 1)
+         names(oth) <- paste0("pca_", names(oth))
+         return(oth)
+       })
+       names(modis_pca_otb_txt) <- names(modis_snip)
+       saveRDS(modis_pca_otb_txt, file = paste0(path_results, "modis_pca_otb_txt_", prj, ".rds"))
+       
+       # Compute Haralick textures for all plots based on NDVI
+       minv <- -1
+       maxv <- 1
+       modis_ndvi_otb_txt <- lapply(seq(length(modis_mspec_indices)), function(i){
+         if(i %% 10 == 0) print(paste0(i))
+         oth <- otbTexturesHaralick(x=modis_mspec_indices[[i]]$NDVI, path_output = path_temp, 
+                                    return_raster = TRUE, 
+                                    parameters.xyrad=list(c(1,1)),
+                                    parameters.xyoff=list(c(1,1)),
+                                    parameters.minmax=c(minv, maxv),
+                                    parameters.nbbin = 16,
+                                    texture="all",
+                                    channel = 1)
+         names(oth) <- paste0("pca_", names(oth))
+         return(oth)
+       })
+       names(modis_ndvi_otb_txt) <- names(modis_snip)
+       saveRDS(modis_ndvi_otb_txt, file = paste0(path_results, "modis_ndvi_otb_txt_", prj, ".rds"))
+       
+       # Compute glcm textures for all plots based on PCA
+       modis_pca_glcm_txt <- lapply(seq(length(modis_pca)), function(i){
+         if(i %% 10 == 0) print(paste0(i))
+         gt <- glcm(modis_pca[[i]]$PC1, n_grey = 32, window = c(3,3),
+                    shift=list(c(0,1), c(1,1), c(1,0), c(1,-1)))
+         names(gt) <- paste0("pca_", names(gt))
+         return(gt)
+       })  
+       names(modis_pca_glcm_txt) <- names(modis_snip)
+       saveRDS(modis_pca_glcm_txt, file = paste0(path_results, "modis_pca_glcm_txt_", prj, ".rds"))
+       
+       # Compute glcm textures for all plots based on NDVI
+       modis_ndvi_glcm_txt <- lapply(seq(length(modis_mspec_indices)), function(i){
+         if(i %% 10 == 0) print(paste0(i))
+         gt <- glcm(modis_mspec_indices[[i]]$NDVI, n_grey = 32, window = c(3,3),
+                    shift=list(c(0,1), c(1,1), c(1,0), c(1,-1)))
+         names(gt) <- paste0("pca_", names(gt))
+         return(gt)
+       })
+       names(modis_ndvi_glcm_txt) <- names(modis_snip)
+       saveRDS(modis_ndvi_glcm_txt, file = paste0(path_results, "modis_ndvi_glcm_txt_", prj, ".rds"))
+       
+       # Combine results in one stack per tile
+       modis_2000 <- lapply(seq(length(modis_snip)), function(i){
+         stack(modis_snip[[i]], modis_pca[[i]], modis_mspec_indices[[i]],
+               modis_pca_otb_txt[[i]], modis_ndvi_otb_txt[[i]],
+               modis_pca_glcm_txt[[i]], modis_ndvi_glcm_txt[[i]])
+       })
+       names(modis_2000) <- names(modis_snip)
+       saveRDS(modis_2000, file = paste0(path_results, "modis_2000_", prj, ".rds"))
+     }
+   }
+ } else {
+   #     modis_snip_wgs <- readRDS(file = paste0(path_results, "modis_snip_wgs.rds"))
+   #     modis_pca_wgs <- readRDS(file = paste0(path_results, "modis_pca_wgs.rds"))
+   #     modis_mspec_indices_wgs <- readRDS(file = paste0(path_results, "modis_mspec_indices_wgs.rds"))
+   #     modis_pca_otb_txt_wgs <- readRDS(file = paste0(path_results, "modis_pca_otb_txt_wgs.rds"))
+   #     modis_ndvi_otb_txt_wgs <- readRDS(file = paste0(path_results, "modis_ndvi_otb_txt_wgs.rds"))
+   #     modis_pca_glcm_txt_wgs <- readRDS(file = paste0(path_results, "modis_pca_glcm_txt_wgs.rds"))
+   #     modis_ndvi_glcm_txt_wgs <- readRDS(file = paste0(path_results, "modis_ndvi_glcm_txt_wgs.rds"))
+   modis_2000_wgs <- readRDS(file = paste0(path_results, "modis_2000_wgs.rds"))
+   
+   #     modis_snip_arc <- readRDS(file = paste0(path_results, "modis_snip_arc.rds"))
+   #     modis_pca_arc <- readRDS(file = paste0(path_results, "modis_pca_arc.rds"))
+   #     modis_mspec_indices_arc <- readRDS(file = paste0(path_results, "modis_mspec_indices_arc.rds"))
+   #     modis_pca_otb_txt_arc <- readRDS(file = paste0(path_results, "modis_pca_otb_txt_arc.rds"))
+   #     modis_ndvi_otb_txt_arc <- readRDS(file = paste0(path_results, "modis_ndvi_otb_txt_arc.rds"))
+   #     modis_pca_glcm_txt_arc <- readRDS(file = paste0(path_results, "modis_pca_glcm_txt_arc.rds"))
+   #     modis_ndvi_glcm_txt_arc <- readRDS(file = paste0(path_results, "modis_ndvi_glcm_txt_arc.rds"))
+   modis_2000_arc <- readRDS(file = paste0(path_results, "modis_2000_arc.rds"))
+ }
[1] "Processing 10 of 257"
[1] "Processing 20 of 257"
